/**
 * @author
 * @version
 */

package hw3;

/**
 * Implements a Board as described in the overview.  A Board represents the
 * current state of the puzzle, containing current tile positions, the cursor
 * position and list of moves the user has made.  For each tile, we also know
 * its starting scrambled coordinates and ending solved coordinates.
 */
public class Board {
    /**
     * Constructs a 2D (array) board of size numRows by numCols, containing a
     * Tracker in position (i, j) for each tile that is currently in position
     * (i, j) of the unsolved Picture.  Initially, for testing purposes, the
     * scrambled indices and the solved indices of each tile are set to the
     * same value (i, j), and this is stored in position (i, j) as if the
     * puzzle is already solved and there is nothing to do.
     *
     * It also initializes the position of the cursor to be at (0, 0), and
     * allocates an empty ArrayList of Strings to contain everything the user
     * has done which has not been removed with an undo operation.
     *
     * Truly scrambled boards are created by calling setTracker repeatedly.
     *
     * @see Board#setTracker
     * @param numRows is the number of tiles vertically
     * @param numCols is the number of tiles horizontally
     */
    public Board(int numRows, int numCols) {
    }

    /**
     * Determines whether the current Board represents a solved state.  There
     * are two possible solved states.  In the first solved state, every tile
     * is in C0, and is in the correct position -- meaning the tile with
     * correctI and correctJ is stored in the corresponding correctI and
     * correctJ positions of the Board.  In the second solved state, every
     * tile is in C0F, and each row is in the correct order from right to
     * left.  This means the solved picture is being looked at from the back,
     * or, is a mirror image of the original picture, but otherwise looks
     * completely normal (see the specification).
     *
     * @return true if the Board is solved, and false otherwise.
     */
    public boolean isSolved() {
    }

    /**
     * Given a tracker generated by a scrambling process (which is beyond the
     * scope of this assignment), store it in position (i, j).
     *
     * @param i the row index to store it in
     * @param j the column index to store it in
     * @param t the Tracker that should be stored
     */
    public void setTracker(int i, int j, Tracker t) {
    }

    /**
     * Return the tracker in a particular row i and column j, corresponding to
     * the tile that is in tile position i and j.
     *
     * @param i the row index to read from
     * @param j the column index to read from
     * @return the tracker at i, and j.
     */
    public Tracker getTracker(int i, int j) {
    }

    /**
     * Get the number of rows on the board corresponding to the number of
     * tiles on the vertical side of the corresponding Picture.
     *
     * @return the number of rows.
     */
    public int getNumRows() {
    }

    /**
     * Get the number of columns on the board corresponding to the number of
     * tiles on the horizontal side of the corresponding Picture.
     *
     * @return the number of columns.
     */
    public int getNumCols() {
    }

    /**
     * Get the current row index of the cursor indicating the tile that will
     * be affected by any "stationary" operations that change the orientation
     * of the tile.
     *
     * @return the row index of the cursor.
     */
    public int getCursorI() {
    }

    /**
     * Get the current column index of the cursor indicating the tile that
     * will be affected by any "stationary" operations that change the
     * orientation of the tile.
     *
     * @return the column index of the cursor.
     */
    public int getCursorJ() {
    }
    
    /**
     * Changes the position of the cursor by increasing the cursor's column
     * index by one, provided the cursor is not already on the rightmost
     * column.  If successful, the move should be recorded on the list of user
     * moves so that it can be undone later if desired.
     */
    public void moveRight() {
    }
    
    /**
     * Changes the position of the cursor by decreasing the cursor's column
     * index by one, provided the cursor is note already on the leftmost
     * column.  If successful, the move should be recorded on the list of user
     * moves so that it can be undone later if desired.
     */
    public void moveLeft() {
    }
    
    /**
     * Changes the position of the cursor by increasing the cursor's row index
     * by one, provided the cursor is note already on the bottommost row.  If
     * successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void moveDown() {
    }
    
    /**
     * Changes the position of the cursor by decreasing the cursor's row
     * index by one, provided the cursor is note already on the topmost
     * row.  If successful, the move should be recorded on the list of user
     * moves so that it can be undone later if desired.
     */
    public void moveUp() {
    }

    /**
     * Records that the user is swapping the tile at the cursor position
     * with its neighbor to the right, and change the position of the cursor
     * by increasing the cursor's column index by one.  These actions are
     * performed only if the cursor is not already on the rightmost column.
     * If successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void swapRight() {
    }

    /**
     * Records that the user is swapping the tile at the cursor position
     * with its neighbor to the left, and change the position of the cursor
     * by decreasing the cursor's column index by one.  These actions are
     * performed only if the cursor is not already on the leftmost column.
     * If successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void swapLeft() {
    }

    /**
     * Records that the user is swapping the tile at the cursor position
     * with its neighbor below, and change the position of the cursor by
     * increasing the cursor's row index by one.  These actions are
     * performed only if the cursor is not already on the bottommost row.
     * If successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void swapDown() {
    }

    /**
     * Records that the user is swapping the tile at the cursor position
     * with its neighbor above, and change the position of the cursor by
     * decreasing the cursor's row index by one.  These actions are
     * performed only if the cursor is not already on the topmost row.
     * If successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void swapUp() {
    }

    /**
     * Records that the user is turning the tile at the cursor position
     * clockwise.  This is always possible, and the move should be recorded
     * on the list of user moves so that it can be undone later if desired.
     */
    public void clockwise() {
    }

    /**
     * Records that the user is turning the tile at the cursor position
     * anticlockwise.  This is always possible, and the move should be
     * recorded on the list of user moves so that it can be undone later if
     * desired.
     */
    public void anticlockwise() {
    }

    /**
     * Records that the user is performing an hflip on the tile at the
     * cursor position.  This is always possible, and the move should be
     * recorded on the list of user moves so that it can be undone later if
     * desired.
     */
    public void hflip() {
    }

    /**
     * Records that the user is performing an vflip on the tile at the
     * cursor position.  This is always possible, and the move should be
     * recorded on the list of user moves so that it can be undone later if
     * desired.
     */
    public void vflip() {
    }

    /**
     * Records that the user is performing a transpose on the tile at the
     * cursor position.  This is always possible, and the move should be
     * recorded on the list of user moves so that it can be undone later if
     * desired.
     */
    public void transpose() {
    }

    /**
     * This undoes the most recent move on the list of user moves, by
     * performing its exact opposite action, and then removing the opposite
     * action as well as the undone action from the list of user moves.  The
     * undo move itself should not be recorded on the list of user moves.
     */
    public void undo() {
    }

    /**
     * Convert the internal state of the entire Board object into the form of
     * a string, including (in this order):
     *
     * - the number of rows on the board, followed by a newline
     * - the number of columns on the board, followed by a newline
     * - the cursor row position, followed by a newline
     * - the cursor column position, followed by a newline
     * - a one line description of each Tracker on the board, reading row by
     *   row in the board (and left to right in each row).  The one-line
     *   description (without its corresponding newline character) must be one
     *   which can be used to initialize a Tracker directly.
     * - a list of all the moves the user has made so far while solving the
     *   puzzle, with each move followed by a newline
     *
     * @return the string representation of the board
     */
    public String save() {
    }

    /**
     * Initialize the internal state of this Board object from the fromString.
     *
     * @see Board#save
     * @param fromString describes in a string format the state of the Board
     *                   object which should be constructed.
     */
    public void load(String fromString) {
    }
}
