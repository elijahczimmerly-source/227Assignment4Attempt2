/**
 * @author
 * @version
 */

package hw3;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Implements a Board as described in the overview.  A Board represents the
 * current state of the puzzle, containing current tile positions, the cursor
 * position and list of moves the user has made.  For each tile, we also know
 * its starting scrambled coordinates and ending solved coordinates.
 */
public class Board {
    Tracker[][] board;
    int cursorI;
    int cursorJ;
    ArrayList<String> userMoves;
	
    
    
    /**
     * Constructs a 2D (array) board of size numRows by numCols, containing a
     * Tracker in position (i, j) for each tile that is currently in position
     * (i, j) of the unsolved Picture.  Initially, for testing purposes, the
     * scrambled indices and the solved indices of each tile are set to the
     * same value (i, j), and this is stored in position (i, j) as if the
     * puzzle is already solved and there is nothing to do.
     *
     * It also initializes the position of the cursor to be at (0, 0), and
     * allocates an empty ArrayList of Strings to contain everything the user
     * has done which has not been removed with an undo operation.
     *
     * Truly scrambled boards are created by calling setTracker repeatedly.
     *
     * @see Board#setTracker
     * @param numRows is the number of tiles vertically
     * @param numCols is the number of tiles horizontally
     */
    public Board(int numRows, int numCols) {
    	board = new Tracker[numRows][numCols];
    	cursorI = 0;
    	cursorJ = 0;
    	userMoves = new ArrayList<>();
    	
    	for(int i = 0; i < numRows; i++) {
    		for (int j = 0; j < numCols; j++) {
    			board[i][j] = new Tracker(i, j, i, j, 0, false);
    		}
    	}
    }

    /**
     * Determines whether the current Board represents a solved state.  There
     * are two possible solved states.  In the first solved state, every tile
     * is in C0, and is in the correct position -- meaning the tile with
     * correctI and correctJ is stored in the corresponding correctI and
     * correctJ positions of the Board.  In the second solved state, every
     * tile is in C0F, and each row is in the correct order from right to
     * left.  This means the solved picture is being looked at from the back,
     * or, is a mirror image of the original picture, but otherwise looks
     * completely normal (see the specification).
     *
     * @return true if the Board is solved, and false otherwise.
     */
    public boolean isSolved() {

    	
    	int numCorrectPos = 0;
    	int numMirrorPos = 0;
    	int numC0 = 0;
    	int numC0F = 0;
    	int boardHeight = board.length;
    	int boardWidth = board[0].length;
    	
    	for (int i = 0; i < boardHeight; i++) {
    		
    		for (int j = 0; j < boardWidth; j++) {
    			
    			
    			Tracker t = board[i][j];
    			
    			if (t.getCorrectI() == i && t.getCorrectJ() == j) {
    				numCorrectPos++;
				}
    			else if (t.getCorrectI() == boardHeight - i && t.getCorrectJ() == boardWidth - j) {
					numMirrorPos++;
				}
    			else{
    				return false;
    			}
    			
    			if(t.getRotations() == 0) {
    				if (t.getIsFlipped()) {
    					numC0F++;
    				}
    				else {
    					numC0++;
    				}
    			}
    			else {
    				return false;
    			}
    			
    			
    		}
    	}
    	
    	int numTiles = boardHeight * boardWidth;
		if(numCorrectPos == numTiles && numC0 == numTiles){
			return true;
		}
		else if(numMirrorPos == numTiles && numC0F == numTiles) {
			return true;
		}
		return false;
    	
    }

    /**
     * Given a tracker generated by a scrambling process (which is beyond the
     * scope of this assignment), store it in position (i, j).
     *
     * @param i the row index to store it in
     * @param j the column index to store it in
     * @param t the Tracker that should be stored
     */
    public void setTracker(int i, int j, Tracker t) {
    	board[i][j] = t;
    }

    /**
     * Return the tracker in a particular row i and column j, corresponding to
     * the tile that is in tile position i and j.
     *
     * @param i the row index to read from
     * @param j the column index to read from
     * @return the tracker at i, and j.
     */
    public Tracker getTracker(int i, int j) {
    	return board[i][j];
    }

    /**
     * Get the number of rows on the board corresponding to the number of
     * tiles on the vertical side of the corresponding Picture.
     *
     * @return the number of rows.
     */
    public int getNumRows() {
    	return board.length;
    }

    /**
     * Get the number of columns on the board corresponding to the number of
     * tiles on the horizontal side of the corresponding Picture.
     *
     * @return the number of columns.
     */
    public int getNumCols() {
    	return board[0].length;
    }

    /**
     * Get the current row index of the cursor indicating the tile that will
     * be affected by any "stationary" operations that change the orientation
     * of the tile.
     *
     * @return the row index of the cursor.
     */
    public int getCursorI() {
    	return cursorI;
    }

    /**
     * Get the current column index of the cursor indicating the tile that
     * will be affected by any "stationary" operations that change the
     * orientation of the tile.
     *
     * @return the column index of the cursor.
     */
    public int getCursorJ() {
    	return cursorJ;
    }
    
    /**
     * Changes the position of the cursor by increasing the cursor's column
     * index by one, provided the cursor is not already on the rightmost
     * column.  If successful, the move should be recorded on the list of user
     * moves so that it can be undone later if desired.
     */
    public void moveRight() {
    	if (cursorJ < board[0].length - 1) {
    		cursorJ++;
    		userMoves.add("moveRight");
    	}
    }
    
    /**
     * Changes the position of the cursor by decreasing the cursor's column
     * index by one, provided the cursor is note already on the leftmost
     * column.  If successful, the move should be recorded on the list of user
     * moves so that it can be undone later if desired.
     */
    public void moveLeft() {
    	if (cursorJ > 0) {
    		cursorJ --;
    		userMoves.add("moveLeft");
    	}
    }
    
    /**
     * Changes the position of the cursor by increasing the cursor's row index
     * by one, provided the cursor is note already on the bottommost row.  If
     * successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void moveDown() {
    	if (cursorI < board[0].length - 1) {
    		cursorI++;
    		userMoves.add("moveDown");
    	}
    }
    
    /**
     * Changes the position of the cursor by decreasing the cursor's row
     * index by one, provided the cursor is note already on the topmost
     * row.  If successful, the move should be recorded on the list of user
     * moves so that it can be undone later if desired.
     */
    public void moveUp() {
    	if (cursorI > 0) {
    		cursorI --;
    		userMoves.add("moveUp");
    	}
    }

    /**
     * Records that the user is swapping the tile at the cursor position
     * with its neighbor to the right, and change the position of the cursor
     * by increasing the cursor's column index by one.  These actions are
     * performed only if the cursor is not already on the rightmost column.
     * If successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void swapRight() {
    	if (cursorJ  < board[0].length - 1) {
    		
    		Tracker temp = board[cursorI][cursorJ];
        	board[cursorI][cursorJ] = board[cursorI][cursorJ + 1];
        	board[cursorI][cursorJ + 1] = temp;
        	
        	cursorJ++;
        	
        	userMoves.add("swapRight");
    	}
    }

    /**
     * Records that the user is swapping the tile at the cursor position
     * with its neighbor to the left, and change the position of the cursor
     * by decreasing the cursor's column index by one.  These actions are
     * performed only if the cursor is not already on the leftmost column.
     * If successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void swapLeft() {
    	if (cursorJ  > 0) {
    		
    		Tracker temp = board[cursorI][cursorJ];
        	board[cursorI][cursorJ] = board[cursorI][cursorJ - 1];
        	board[cursorI][cursorJ - 1] = temp;
        	
        	cursorJ--;
        	
        	userMoves.add("swapLeft");
    	}
    }

    /**
     * Records that the user is swapping the tile at the cursor position
     * with its neighbor below, and change the position of the cursor by
     * increasing the cursor's row index by one.  These actions are
     * performed only if the cursor is not already on the bottommost row.
     * If successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void swapDown() {
    	if (cursorI  < board.length - 1) {
    		
    		Tracker temp = board[cursorI][cursorJ];
        	board[cursorI][cursorJ] = board[cursorI + 1][cursorJ];
        	board[cursorI + 1][cursorJ] = temp;
        	
        	cursorI++;
        	
        	userMoves.add("swapDown");
    	}
    }

    /**
     * Records that the user is swapping the tile at the cursor position
     * with its neighbor above, and change the position of the cursor by
     * decreasing the cursor's row index by one.  These actions are
     * performed only if the cursor is not already on the topmost row.
     * If successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void swapUp() {
    	if (cursorI  > 0) {
    		
    		Tracker temp = board[cursorI][cursorJ];
        	board[cursorI][cursorJ] = board[cursorI - 1][cursorJ];
        	board[cursorI - 1][cursorJ] = temp;
        	
        	cursorI--;
        	
        	userMoves.add("swapUp");
    	}
    }

    /**
     * Records that the user is turning the tile at the cursor position
     * clockwise.  This is always possible, and the move should be recorded
     * on the list of user moves so that it can be undone later if desired.
     */
    public void clockwise() {
    	board[cursorI][cursorJ].clockwise();
    	userMoves.add("clockwise");
    }

    /**
     * Records that the user is turning the tile at the cursor position
     * anticlockwise.  This is always possible, and the move should be
     * recorded on the list of user moves so that it can be undone later if
     * desired.
     */
    public void anticlockwise() {
    	board[cursorI][cursorJ].anticlockwise();
    	userMoves.add("anticlockwise");
    }

    /**
     * Records that the user is performing an hflip on the tile at the
     * cursor position.  This is always possible, and the move should be
     * recorded on the list of user moves so that it can be undone later if
     * desired.
     */
    public void hflip() {
    	board[cursorI][cursorJ].hflip();
    	userMoves.add("hflip");
    }

    /**
     * Records that the user is performing an vflip on the tile at the
     * cursor position.  This is always possible, and the move should be
     * recorded on the list of user moves so that it can be undone later if
     * desired.
     */
    public void vflip() {
    	board[cursorI][cursorJ].vflip();
    	userMoves.add("vflip");
    }

    /**
     * Records that the user is performing a transpose on the tile at the
     * cursor position.  This is always possible, and the move should be
     * recorded on the list of user moves so that it can be undone later if
     * desired.
     */
    public void transpose() {
    	board[cursorI][cursorJ].transpose();
    	userMoves.add("transpose");
    }

    /**
     * This undoes the most recent move on the list of user moves, by
     * performing its exact opposite action, and then removing the opposite
     * action as well as the undone action from the list of user moves.  The
     * undo move itself should not be recorded on the list of user moves.
     */
    public void undo() {
    	if (userMoves.size() >= 1) {
    		String lastMove = userMoves.remove(userMoves.size() - 1);
        	switch(lastMove) {
        		case "" : break;
        		case "moveRight" : moveLeft(); break;
        		case "moveLeft" : moveRight(); break;
        		case "moveDown" : moveUp(); break;
        		case "moveUp" : moveDown(); break;
        		case "swapRight" : swapLeft(); break;
        		case "swapLeft" : swapRight(); break;
        		case "swapDown" : swapUp(); break;
        		case "swapUp" : swapDown(); break;
        		case "clockwise" : anticlockwise(); break;
        		case "anticlockwise" : clockwise(); break;
        		case "hflip" : hflip(); break;
        		case "vflip" : vflip(); break;
        		case "transpose" : transpose(); break;
        	}
    	}
    	
    }

    /**
     * Convert the internal state of the entire Board object into the form of
     * a string, including (in this order):
     *
     * - the number of rows on the board, followed by a newline
     * - the number of columns on the board, followed by a newline
     * - the cursor row position, followed by a newline
     * - the cursor column position, followed by a newline
     * - a one line description of each Tracker on the board, reading row by
     *   row in the board (and left to right in each row).  The one-line
     *   description (without its corresponding newline character) must be one
     *   which can be used to initialize a Tracker directly.
     * - a list of all the moves the user has made so far while solving the
     *   puzzle, with each move followed by a newline
     *
     * @return the string representation of the board
     */
    public String save() {
    	String boardString = board.length + "\n" + board[0].length + "\n" + cursorI + "\n" + cursorJ + "\n"; 
    	
    	for (int i = 0; i < board.length; i++) {
    		for (int j = 0; j < board[0].length; j++) {
    			boardString += board[i][j] + "\n";
    		}
    	}
    	
    	for (int i = 0; i < userMoves.size(); i++) {
    		boardString += userMoves.get(i) + "\n";
    	}
    			
    	return boardString;
    }

    /**
     * Initialize the internal state of this Board object from the fromString.
     *
     * @see Board#save
     * @param fromString describes in a string format the state of the Board
     *                   object which should be constructed.
     */
    public void load(String fromString) {
    	Scanner scnr = new Scanner(fromString);
    	
    	board = new Tracker[scnr.nextInt()][scnr.nextInt()];
    	cursorI = scnr.nextInt();
    	cursorJ  = scnr.nextInt();
    	
    	for (int i = 0; i < board.length; i++) {
    		for (int j = 0; j < board[0].length; j++) {
    			board[i][j] = new Tracker(scnr.nextLine());
    		}
    	}
    	
    	userMoves = new ArrayList<String>();
    	while(scnr.hasNextLine()) {
    		userMoves.add(scnr.nextLine());
    	}
    	
    	scnr.close();
    }
}
